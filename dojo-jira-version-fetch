import requests
import time
import logging
import re
from datetime import datetime, timedelta

# Constants (replace with your actual values)
DEFECTDOJO_TESTS_URL = 'https://demo.defectdojo.org/api/v2/tests/'
DEFECTDOJO_ENGAGEMENTS_URL = 'https://demo.defectdojo.org/api/v2/engagements/'
HEADERS_DEFECTDOJO = {
    'Authorization': 'Token 123232323232323',  # Replace with your API token
    'Content-Type': 'application/json'
}

JIRA_API_URL = "https://jira.demo.almworks.com/rest/api/2/search"  # Your Jira API endpoint
JIRA_API_TOKEN = "gfgdgdgdgdgdgdg"  # Replace with your Jira API token
JIRA_HEADERS = {
    'Authorization': f'Bearer {JIRA_API_TOKEN}',
    'Content-Type': 'application/json'
}

HARDCODED_TEST_TYPE = 29  # Test type for Manual Code Review
HARDCODED_SCAN_TYPE = "Manual Code Review"  # Scan type
HARDCODED_ENVIRONMENT = 1  # Environment

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# Function to handle requests with retries & pagination
def request_with_retry(url, method="GET", headers=None, json=None, max_retries=3, delay=2):
    for attempt in range(max_retries):
        try:
            sanitized_headers = {k: (v if k != 'Authorization' else 'Token <REDACTED>') for k, v in headers.items()}
            logger.debug(f"Making {method} request to {url} with headers: {sanitized_headers}")
            
            response = requests.request(method, url, headers=headers, json=json)
            if response.status_code in [200, 201]:
                return response
            else:
                logger.error(f"❌ Error: {response.status_code} - {response.text}")
                break

        except requests.exceptions.RequestException as e:
            logger.error(f"❌ Network error: {str(e)}. Retrying in {delay} seconds...")
            time.sleep(delay)
    return None

# Function to fetch all paginated results from an API
def fetch_paginated_results(base_url, headers):
    results = []
    page = 1

    while True:
        url = f"{base_url}&page={page}"
        response = request_with_retry(url, "GET", headers=headers)
        if response is None:
            break

        data = response.json()
        if "results" in data:
            results.extend(data["results"])

        if not data.get("next"):  # If there are no more pages, stop
            break

        page += 1

    return results

# Function to fetch Jira issues with pagination
def get_jira_issues(version):
    """Fetch Jira issue keys where labels in (version) OR 'Build(s)' in (version) with pagination."""
    if not version:
        logger.warning("⚠️ No version provided, skipping Jira issue fetching.")
        return []

    jql_query = f'labels in ("{version}") OR "Build(s)" in ("{version}")'
    start_at = 0
    max_results = 50  # Jira API default limit
    issue_keys = []

    while True:
        url = f"{JIRA_API_URL}?jql={jql_query}&fields=key&startAt={start_at}&maxResults={max_results}"
        response = request_with_retry(url, "GET", headers=JIRA_HEADERS)
        
        if response is None:
            break

        issues = response.json().get("issues", [])
        issue_keys.extend([issue["key"] for issue in issues])

        if len(issues) < max_results:  # Stop if fewer results returned
            break

        start_at += max_results  # Move to the next page

    logger.info(f"Fetched {len(issue_keys)} Jira issue keys for version '{version}'")
    return issue_keys

# Function to fetch existing tests from DefectDojo
def get_existing_tests(engagement_id):
    url = f"{DEFECTDOJO_TESTS_URL}?engagement={engagement_id}"
    tests = fetch_paginated_results(url, HEADERS_DEFECTDOJO)
    return {test["title"].strip().lower() for test in tests if test["title"]}

# Function to fetch engagement details (including version)
def get_engagement_details(engagement_id):
    url = f"{DEFECTDOJO_ENGAGEMENTS_URL}{engagement_id}/"
    response = request_with_retry(url, "GET", headers=HEADERS_DEFECTDOJO)
    return response.json() if response else None

# Function to create tests in DefectDojo
def create_tests_in_defectdojo(engagement_id):
    engagement_details = get_engagement_details(engagement_id)
    if not engagement_details:
        logger.info(f"Skipping engagement {engagement_id}: No details found.")
        return
    
    status = engagement_details.get("status", "").lower()
    if status == "completed":
        logger.info(f"Skipping engagement {engagement_id}: Status 'completed'.")
        return

    version = engagement_details.get("version", "").strip()
    if not version:
        logger.info(f"Skipping engagement {engagement_id}: No version found.")
        return

    lead = engagement_details.get("lead")
    target_start = engagement_details.get("target_start") or datetime.now().strftime("%Y-%m-%d")
    target_end = engagement_details.get("target_end") or (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")

    # Fetch Jira issues
    jira_issue_keys = get_jira_issues(version)
    if not jira_issue_keys:
        logger.info(f"No Jira issue keys found for version '{version}', skipping test creation.")
        return

    # Fetch existing test titles
    existing_test_titles = get_existing_tests(engagement_id)

    for issue_key in jira_issue_keys:
        test_title = issue_key  # Title contains only the Jira key

        if test_title.lower() in existing_test_titles:
            logger.info(f"Test '{test_title}' already exists in engagement {engagement_id}, skipping.")
            continue
        
        payload = {
            "engagement": engagement_id,
            "title": test_title,
            "description": "",
            "test_type": HARDCODED_TEST_TYPE,
            "scan_type": HARDCODED_SCAN_TYPE,
            "environment": HARDCODED_ENVIRONMENT,
            "lead": lead,
            "target_start": target_start,
            "target_end": target_end,
            "version": version  # Use version from engagement
        }
        response = request_with_retry(DEFECTDOJO_TESTS_URL, "POST", headers=HEADERS_DEFECTDOJO, json=payload)
        if response and response.status_code == 201:
            logger.info(f"✅ Created test '{test_title}' in engagement {engagement_id} with version '{version}'")
        else:
            logger.error(f"❌ Failed to create test '{test_title}'.")

# Function to fetch all engagement IDs from DefectDojo
def fetch_engagement_ids_from_defectdojo(tags_filter="pci"):
    url = f"{DEFECTDOJO_ENGAGEMENTS_URL}?tags={tags_filter}&status=Not Started&limit=100"
    engagements = fetch_paginated_results(url, HEADERS_DEFECTDOJO)

    url = f"{DEFECTDOJO_ENGAGEMENTS_URL}?tags={tags_filter}&status=In Progress&limit=100"
    engagements.extend(fetch_paginated_results(url, HEADERS_DEFECTDOJO))

    return [engagement["id"] for engagement in engagements]

# Main execution function
def main():
    engagement_ids = fetch_engagement_ids_from_defectdojo()
    if not engagement_ids:
        return

    processed_engagement_ids = set()
    for engagement_id in engagement_ids:
        if engagement_id in processed_engagement_ids:
            continue
        
        create_tests_in_defectdojo(engagement_id)
        processed_engagement_ids.add(engagement_id)

if __name__ == "__main__":
    main()